// src/utils/chessLogic.ts

// --- TIPOS ---
export type PieceColor = 'white' | 'black';
export type PieceType = 'pawn' | 'rook' | 'knight' | 'bishop' | 'queen' | 'king';
export type BoardState = (string | null)[][];

interface Move {
    fromRow: number;
    fromCol: number;
    toRow: number;
    toCol: number;
    piece: string;
}

// --- TABLAS DE VALORACIÓN (Estrategia posicional) ---
// Valores para las BLANCAS.

const pawnTable = [
    [0,  0,  0,  0,  0,  0,  0,  0],
    [50, 50, 50, 50, 50, 50, 50, 50],
    [10, 10, 20, 30, 30, 20, 10, 10],
    [5,  5, 10, 25, 25, 10,  5,  5],
    [0,  0,  0, 20, 20,  0,  0,  0],
    [5, -5,-10,  0,  0,-10, -5,  5],
    [5, 10, 10,-20,-20, 10, 10,  5],
    [0,  0,  0,  0,  0,  0,  0,  0]
];

const knightTable = [
    [-50,-40,-30,-30,-30,-30,-40,-50],
    [-40,-20,  0,  0,  0,  0,-20,-40],
    [-30,  0, 10, 15, 15, 10,  0,-30],
    [-30,  5, 15, 20, 20, 15,  5,-30],
    [-30,  0, 15, 20, 20, 15,  0,-30],
    [-30,  5, 10, 15, 15, 10,  5,-30],
    [-40,-20,  0,  5,  5,  0,-20,-40],
    [-50,-40,-30,-30,-30,-30,-40,-50]
];

const bishopTable = [
    [-20,-10,-10,-10,-10,-10,-10,-20],
    [-10,  0,  0,  0,  0,  0,  0,-10],
    [-10,  0,  5, 10, 10,  5,  0,-10],
    [-10,  5,  5, 10, 10,  5,  5,-10],
    [-10,  0, 10, 10, 10, 10,  0,-10],
    [-10, 10, 10, 10, 10, 10, 10,-10],
    [-10,  5,  0,  0,  0,  0,  5,-10],
    [-20,-10,-10,-10,-10,-10,-10,-20]
];

const rookTable = [
    [0,  0,  0,  0,  0,  0,  0,  0],
    [5, 10, 10, 10, 10, 10, 10,  5],
    [-5,  0,  0,  0,  0,  0,  0, -5],
    [-5,  0,  0,  0,  0,  0,  0, -5],
    [-5,  0,  0,  0,  0,  0,  0, -5],
    [-5,  0,  0,  0,  0,  0,  0, -5],
    [-5,  0,  0,  0,  0,  0,  0, -5],
    [0,  0,  0,  5,  5,  0,  0,  0]
];

const queenTable = [
    [-20,-10,-10, -5, -5,-10,-10,-20],
    [-10,  0,  0,  0,  0,  0,  0,-10],
    [-10,  0,  5,  5,  5,  5,  0,-10],
    [-5,  0,  5,  5,  5,  5,  0, -5],
    [0,  0,  5,  5,  5,  5,  0, -5],
    [-10,  5,  5,  5,  5,  5,  0,-10],
    [-10,  0,  5,  0,  0,  0,  0,-10],
    [-20,-10,-10, -5, -5,-10,-10,-20]
];

const kingTableMidGame = [
    [-30,-40,-40,-50,-50,-40,-40,-30],
    [-30,-40,-40,-50,-50,-40,-40,-30],
    [-30,-40,-40,-50,-50,-40,-40,-30],
    [-30,-40,-40,-50,-50,-40,-40,-30],
    [-20,-30,-30,-40,-40,-30,-30,-20],
    [-10,-20,-20,-20,-20,-20,-20,-10],
    [20, 20,  0,  0,  0,  0, 20, 20],
    [20, 30, 10,  0,  0, 10, 30, 20]
];

// --- ESTADO GLOBAL ---
let lastMove: { piece: string, fromRow: number, fromCol: number, toRow: number, toCol: number } | null = null;
const positionHistory: string[] = []; // Historial de tableros (FEN simplificado)
let halfMoveClock: number = 0;
const kingMoved = { white: false, black: false };
const rookMoved = { 'white-0': false, 'white-7': false, 'black-0': false, 'black-7': false };

export function initializeBoard(): BoardState {
    return [
        ["rook-black", "knight-black", "bishop-black", "queen-black", "king-black", "bishop-black", "knight-black", "rook-black"],
        ["pawn-black", "pawn-black", "pawn-black", "pawn-black", "pawn-black", "pawn-black", "pawn-black", "pawn-black"],
        [null, null, null, null, null, null, null, null],
        [null, null, null, null, null, null, null, null],
        [null, null, null, null, null, null, null, null],
        [null, null, null, null, null, null, null, null],
        ["pawn-white", "pawn-white", "pawn-white", "pawn-white", "pawn-white", "pawn-white", "pawn-white", "pawn-white"],
        ["rook-white", "knight-white", "bishop-white", "queen-white", "king-white", "bishop-white", "knight-white", "rook-white"]
    ];
}

// --- GETTERS & SETTERS ---
export function getLastMove() { return lastMove; }
export function setLastMove(move: { piece: string, fromRow: number, fromCol: number, toRow: number, toCol: number }) { lastMove = move; }
export function resetHalfMoveClock() { halfMoveClock = 0; }
export function incrementHalfMoveClock() { halfMoveClock++; }
export function setKingMoved(color: PieceColor) { kingMoved[color] = true; }
export function setRookMoved(color: PieceColor, col: 0 | 7) { rookMoved[`${color}-${col}`] = true; }

// Verifica repetición para reglas del juego (y para la IA)
export function isThreefoldRepetition(board: BoardState, updateHistory = true): boolean {
    const boardString = board.map(row => row.join(',')).join(';');
    if (updateHistory) positionHistory.push(boardString);
    const occurrences = positionHistory.filter(position => position === boardString).length;
    return occurrences >= 3;
}
export function isFiftyMoveRule(): boolean { return halfMoveClock >= 50; }

// --- VALIDACIÓN DE MOVIMIENTOS ---

export function isValidMove(board: BoardState, pieceType: string, fromRow: number, fromCol: number, toRow: number, toCol: number, toSquare: string | null): boolean {
    const rowDiff = Math.abs(toRow - fromRow);
    const colDiff = Math.abs(toCol - fromCol);
    const type = pieceType.split('-')[0] as PieceType;
    const color = pieceType.split('-')[1] as PieceColor;

    if (toSquare && toSquare.includes(color)) return false; 

    let geometryValid = false;
    switch (type) {
        case 'pawn':
            geometryValid = isValidPawnMove(pieceType, fromRow, fromCol, toRow, toCol, toSquare);
            break;
        case 'rook':
            geometryValid = (fromRow === toRow || fromCol === toCol) && isPathClear(board, fromRow, fromCol, toRow, toCol);
            break;
        case 'knight':
            geometryValid = (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);
            break;
        case 'bishop':
            geometryValid = (rowDiff === colDiff) && isPathClear(board, fromRow, fromCol, toRow, toCol);
            break;
        case 'queen':
            geometryValid = ((fromRow === toRow || fromCol === toCol) || (rowDiff === colDiff)) && isPathClear(board, fromRow, fromCol, toRow, toCol);
            break;
        case 'king':
            geometryValid = (rowDiff <= 1 && colDiff <= 1);
            if (!geometryValid && rowDiff === 0 && colDiff === 2) {
                return isValidCastling(board, pieceType, fromRow, fromCol, toRow, toCol);
            }
            break;
    }

    if (!geometryValid) return false;

    // Simular para validar Jaque
    const newBoard = simulateMove(board, { fromRow, fromCol, toRow, toCol, piece: pieceType });
    if (isKingInCheck(newBoard, color)) return false;

    return true;
}

// --- GENERACIÓN DE MOVIMIENTOS ---

function getAllPossibleMoves(board: BoardState, color: PieceColor): Move[] {
    const moves: Move[] = [];
    
    for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
            const piece = board[r][c];
            if (!piece || !piece.includes(color)) continue;

            const type = piece.split('-')[0] as PieceType;
            
            switch (type) {
                case 'pawn':
                    generatePawnMoves(board, r, c, color, piece, moves);
                    break;
                case 'knight':
                    const knightOffsets = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
                    for (const [dr, dc] of knightOffsets) tryAddMove(board, r, c, r+dr, c+dc, piece, color, moves);
                    break;
                case 'king':
                    const kingOffsets = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
                    for (const [dr, dc] of kingOffsets) tryAddMove(board, r, c, r+dr, c+dc, piece, color, moves);
                    break;
                case 'bishop':
                    generateSlidingMoves(board, r, c, [[-1,-1],[-1,1],[1,-1],[1,1]], piece, color, moves);
                    break;
                case 'rook':
                    generateSlidingMoves(board, r, c, [[-1,0],[1,0],[0,-1],[0,1]], piece, color, moves);
                    break;
                case 'queen':
                    generateSlidingMoves(board, r, c, [[-1,-1],[-1,1],[1,-1],[1,1],[-1,0],[1,0],[0,-1],[0,1]], piece, color, moves);
                    break;
            }
        }
    }
    return moves;
}

function tryAddMove(board: BoardState, fr: number, fc: number, tr: number, tc: number, piece: string, color: PieceColor, moves: Move[]) {
    if (tr < 0 || tr > 7 || tc < 0 || tc > 7) return; 
    const target = board[tr][tc];
    if (target && target.includes(color)) return; 

    // Simular para validar Jaque 
    const newBoard = simulateMove(board, {fromRow: fr, fromCol: fc, toRow: tr, toCol: tc, piece});
    if (!isKingInCheck(newBoard, color)) {
        moves.push({ fromRow: fr, fromCol: fc, toRow: tr, toCol: tc, piece });
    }
}

function generatePawnMoves(board: BoardState, r: number, c: number, color: PieceColor, piece: string, moves: Move[]) {
    const dir = color === 'white' ? -1 : 1;
    const startRow = color === 'white' ? 6 : 1;

    // 1. Avance simple
    if (!board[r + dir]?.[c]) {
        tryAddMove(board, r, c, r + dir, c, piece, color, moves);
        // 2. Avance doble 
        if (r === startRow && !board[r + 2 * dir]?.[c]) {
            tryAddMove(board, r, c, r + 2 * dir, c, piece, color, moves);
        }
    }
    // 3. Capturas
    const captureCols = [c - 1, c + 1];
    for (const cc of captureCols) {
        if (cc >= 0 && cc <= 7) {
            const target = board[r + dir]?.[cc];
            if (target && !target.includes(color)) {
                tryAddMove(board, r, c, r + dir, cc, piece, color, moves);
            }
        }
    }
}

function generateSlidingMoves(board: BoardState, r: number, c: number, dirs: number[][], piece: string, color: PieceColor, moves: Move[]) {
    for (const [dr, dc] of dirs) {
        let tr = r + dr;
        let tc = c + dc;
        while (tr >= 0 && tr <= 7 && tc >= 0 && tc <= 7) {
            const target = board[tr][tc];
            if (target) {
                if (!target.includes(color)) {
                    tryAddMove(board, r, c, tr, tc, piece, color, moves); 
                }
                break; 
            }
            tryAddMove(board, r, c, tr, tc, piece, color, moves); 
            tr += dr;
            tc += dc;
        }
    }
}

// --- AYUDANTES DE LÓGICA ---

function simulateMove(board: BoardState, move: Move): BoardState {
    const newBoard = board.map(row => row.slice());
    newBoard[move.toRow][move.toCol] = move.piece;
    newBoard[move.fromRow][move.fromCol] = null;
    return newBoard;
}

function isValidPawnMove(pieceType: string, fromRow: number, fromCol: number, toRow: number, toCol: number, toSquare: string | null): boolean {
    const direction = pieceType.includes('white') ? -1 : 1;
    const startRow = pieceType.includes('white') ? 6 : 1;
    if (fromCol === toCol && toRow === fromRow + direction && !toSquare) return true;
    if (fromCol === toCol && fromRow === startRow && toRow === fromRow + 2 * direction && !toSquare) return true; 
    if (Math.abs(fromCol - toCol) === 1 && toRow === fromRow + direction && toSquare) return true;
    if (Math.abs(fromCol - toCol) === 1 && toRow === fromRow + direction && !toSquare) {
        const last = getLastMove();
        if (last && last.piece.includes('pawn') && Math.abs(last.fromRow - last.toRow) === 2) {
            if (last.toRow === fromRow && Math.abs(last.toCol - fromCol) === 1) return true;
        }
    }
    return false;
}

function isPathClear(board: BoardState, fromRow: number, fromCol: number, toRow: number, toCol: number): boolean {
    const rowStep = Math.sign(toRow - fromRow);
    const colStep = Math.sign(toCol - fromCol);
    let r = fromRow + rowStep;
    let c = fromCol + colStep;
    while (r !== toRow || c !== toCol) {
        if (board[r][c] !== null) return false;
        r += rowStep;
        c += colStep;
    }
    return true;
}

// --- JAQUE Y ATAQUES ---

export function isKingInCheck(board: BoardState, kingColor: PieceColor): boolean {
    const kingPos = findKing(board, kingColor);
    if (!kingPos) return false; 
    return isSquareAttacked(board, kingPos[0], kingPos[1], kingColor);
}

function isSquareAttacked(board: BoardState, r: number, c: number, color: PieceColor): boolean {
    const opponentColor = color === 'white' ? 'black' : 'white';
    
    // Peones
    const pawnDir = color === 'white' ? -1 : 1; 
    if (board[r+pawnDir]?.[c-1] === `pawn-${opponentColor}`) return true;
    if (board[r+pawnDir]?.[c+1] === `pawn-${opponentColor}`) return true;

    // Caballos
    const kOffsets = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
    for (const [dr, dc] of kOffsets) {
        if (board[r+dr]?.[c+dc] === `knight-${opponentColor}`) return true;
    }

    // Rey
    for (let i=-1; i<=1; i++) for (let j=-1; j<=1; j++) {
        if (i===0 && j===0) continue;
        if (board[r+i]?.[c+j] === `king-${opponentColor}`) return true;
    }

    // Torres/Reinas
    const orthodirs = [[-1,0],[1,0],[0,-1],[0,1]];
    for (const [dr, dc] of orthodirs) {
        let tr = r + dr, tc = c + dc;
        while (tr>=0 && tr<=7 && tc>=0 && tc<=7) {
            const p = board[tr][tc];
            if (p) {
                if (p === `rook-${opponentColor}` || p === `queen-${opponentColor}`) return true;
                break;
            }
            tr += dr; tc += dc;
        }
    }

    // Alfiles/Reinas
    const diagdirs = [[-1,-1],[-1,1],[1,-1],[1,1]];
    for (const [dr, dc] of diagdirs) {
        let tr = r + dr, tc = c + dc;
        while (tr>=0 && tr<=7 && tc>=0 && tc<=7) {
            const p = board[tr][tc];
            if (p) {
                if (p === `bishop-${opponentColor}` || p === `queen-${opponentColor}`) return true;
                break;
            }
            tr += dr; tc += dc;
        }
    }
    return false;
}

function findKing(board: BoardState, color: PieceColor): [number, number] | null {
    for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
            if (board[r][c] === `king-${color}`) return [r, c];
        }
    }
    return null;
}

// --- ENROQUE ---

function isValidCastling(board: BoardState, pieceType: string, fromRow: number, fromCol: number, toRow: number, toCol: number): boolean {
    const color = pieceType.split('-')[1] as PieceColor;
    if (kingMoved[color] || isKingInCheck(board, color)) return false;

    // Corto
    if (toCol === fromCol + 2) {
        if (rookMoved[`${color}-7`] || board[fromRow][7] !== `rook-${color}`) return false;
        if (board[fromRow][fromCol+1] || board[fromRow][fromCol+2]) return false; 
        if (isSquareAttacked(board, fromRow, fromCol+1, color) || isSquareAttacked(board, fromRow, fromCol+2, color)) return false;
        return true;
    }
    // Largo
    if (toCol === fromCol - 2) {
        if (rookMoved[`${color}-0`] || board[fromRow][0] !== `rook-${color}`) return false;
        if (board[fromRow][fromCol-1] || board[fromRow][fromCol-2] || board[fromRow][fromCol-3]) return false;
        if (isSquareAttacked(board, fromRow, fromCol-1, color) || isSquareAttacked(board, fromRow, fromCol-2, color)) return false;
        return true;
    }
    return false;
}

export function isCheckmate(board: BoardState, color: PieceColor): boolean {
    if (!isKingInCheck(board, color)) return false;
    const moves = getAllPossibleMoves(board, color);
    return moves.length === 0;
}

export function isStalemate(board: BoardState, color: PieceColor): boolean {
    if (isKingInCheck(board, color)) return false;
    const moves = getAllPossibleMoves(board, color);
    return moves.length === 0;
}

// --- INTELIGENCIA ARTIFICIAL (MINIMAX + ALPHA-BETA) ---

function evaluateBoard(board: BoardState, aiColor: PieceColor): number {
    let score = 0;
    
    // Contamos movilidad para evitar que la IA se quede quieta
    const opponentColor = aiColor === 'white' ? 'black' : 'white';
    const myMoves = getAllPossibleMoves(board, aiColor).length;
    const oppMoves = getAllPossibleMoves(board, opponentColor).length;
    
    score += (myMoves - oppMoves) * 0.1; // Bonus de movilidad pequeño

    for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
            const piece = board[r][c];
            if (piece) {
                const [type, pColor] = piece.split('-') as [PieceType, PieceColor];
                const isWhite = pColor === 'white';
                
                const tr = isWhite ? r : 7 - r;
                const tc = c;

                let val = 0;
                switch(type) {
                    case 'pawn': val = 100 + pawnTable[tr][tc]; break;
                    case 'knight': val = 320 + knightTable[tr][tc]; break;
                    case 'bishop': val = 330 + bishopTable[tr][tc]; break;
                    case 'rook': val = 500 + rookTable[tr][tc]; break;
                    case 'queen': val = 900 + queenTable[tr][tc]; break;
                    case 'king': val = 20000 + kingTableMidGame[tr][tc]; break;
                }
                score += (pColor === aiColor ? val : -val);
            }
        }
    }
    return score;
}

function minimax(board: BoardState, depth: number, alpha: number, beta: number, isMaximizing: boolean, aiColor: PieceColor): number {
    if (depth === 0) return evaluateBoard(board, aiColor);

    const currentPlayer = isMaximizing ? aiColor : (aiColor === 'white' ? 'black' : 'white');
    const possibleMoves = getAllPossibleMoves(board, currentPlayer);

    if (possibleMoves.length === 0) {
        if (isKingInCheck(board, currentPlayer)) {
            // Mate lo antes posible: Sumamos/Restamos depth para preferir mates cercanos
            return isMaximizing ? -100000 - depth : 100000 + depth; 
        }
        return 0; // Ahogado
    }

    possibleMoves.sort(() => Math.random() - 0.5);

    if (isMaximizing) {
        let maxEval = -Infinity;
        for (const move of possibleMoves) {
            const newBoard = simulateMove(board, move);
            const ev = minimax(newBoard, depth - 1, alpha, beta, false, aiColor);
            maxEval = Math.max(maxEval, ev);
            alpha = Math.max(alpha, ev);
            if (beta <= alpha) break;
        }
        return maxEval;
    } else {
        let minEval = Infinity;
        for (const move of possibleMoves) {
            const newBoard = simulateMove(board, move);
            const ev = minimax(newBoard, depth - 1, alpha, beta, true, aiColor);
            minEval = Math.min(minEval, ev);
            beta = Math.min(beta, ev);
            if (beta <= alpha) break;
        }
        return minEval;
    }
}

export function makeAIMove(board: BoardState, aiColor: PieceColor): BoardState {
    const depth = 3; 
    const moves = getAllPossibleMoves(board, aiColor);
    
    if (moves.length === 0) return board;

    let bestMove = moves[0];
    let bestValue = -Infinity;
    let alpha = -Infinity;
    let beta = Infinity;

    // Priorizar capturas para podar el árbol más rápido
    moves.sort((a, b) => {
        const pieceA = board[a.toRow][a.toCol];
        const pieceB = board[b.toRow][b.toCol];
        return (pieceB ? 10 : 0) - (pieceA ? 10 : 0);
    });

    for (const move of moves) {
        const newBoard = simulateMove(board, move);
        
        // --- EVITAR REPETICIÓN ---
        // Verificamos si este movimiento lleva a una posición que ya hemos visto
        const boardStr = newBoard.map(row => row.join(',')).join(';');
        const isRepeated = positionHistory.includes(boardStr);
        let val = minimax(newBoard, depth - 1, alpha, beta, false, aiColor);

        // Penalización por repetición (a menos que sea la única opción para salvarse)
        if (isRepeated) val -= 50; 

        if (val > bestValue) {
            bestValue = val;
            bestMove = move;
        }
        alpha = Math.max(alpha, bestValue);
    }

    if (bestMove) {
        const finalBoard = simulateMove(board, bestMove);
        setLastMove({ piece: bestMove.piece, fromRow: bestMove.fromRow, fromCol: bestMove.fromCol, toRow: bestMove.toRow, toCol: bestMove.toCol });
        return finalBoard;
    }

    return board;
}